name: CI/CD Microservicios - Docker Build & AWS Deploy

on:
  push:
    branches:
      - main
      - dev
      - qa
    paths:
      - 'services/**'
      - 'infra/**'
      - '.github/workflows/**'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  # ============================================================
  # JOB 1: DETECTAR CAMBIOS
  # ============================================================
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      users-changed: ${{ steps.changes.outputs.users-changed }}
      orders-changed: ${{ steps.changes.outputs.orders-changed }}
      notifications-changed: ${{ steps.changes.outputs.notifications-changed }}
      any-service-changed: ${{ steps.changes.outputs.any-service-changed }}
      infra-changed: ${{ steps.changes.outputs.infra-changed }}
      services-to-build: ${{ steps.changes.outputs.services-to-build }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed files
        id: changes
        run: |
          # Detectar cambios en servicios e infraestructura
          CHANGED_FILES=$(git diff --name-only ${{ github.event.before }} ${{ github.sha }} || echo "")
          
          USERS_CHANGED=false
          ORDERS_CHANGED=false
          NOTIFICATIONS_CHANGED=false
          INFRA_CHANGED=false
          
          if echo "$CHANGED_FILES" | grep -q '^services/users/'; then
            USERS_CHANGED=true
            echo "âœ… Changes detected in ms-users"
          fi
          
          if echo "$CHANGED_FILES" | grep -q '^services/orders/'; then
            ORDERS_CHANGED=true
            echo "âœ… Changes detected in ms-orders"
          fi
          
          if echo "$CHANGED_FILES" | grep -q '^services/notifications/'; then
            NOTIFICATIONS_CHANGED=true
            echo "âœ… Changes detected in ms-notifications"
          fi
          
          if echo "$CHANGED_FILES" | grep -q '^infra/'; then
            INFRA_CHANGED=true
            echo "âœ… Changes detected in infrastructure"
          fi
          
          # Si es workflow_dispatch, construir todo
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            USERS_CHANGED=true
            ORDERS_CHANGED=true
            NOTIFICATIONS_CHANGED=true
            INFRA_CHANGED=true
            echo "ðŸ”„ Manual trigger - Building and deploying everything"
          fi
          
          ANY_CHANGED=false
          if [ "$USERS_CHANGED" == "true" ] || [ "$ORDERS_CHANGED" == "true" ] || [ "$NOTIFICATIONS_CHANGED" == "true" ]; then
            ANY_CHANGED=true
          fi
          
          # Create JSON array of services to build
          SERVICES="[]"
          if [ "$USERS_CHANGED" == "true" ]; then
            SERVICES=$(echo "$SERVICES" | jq '. + ["users"]')
          fi
          if [ "$ORDERS_CHANGED" == "true" ]; then
            SERVICES=$(echo "$SERVICES" | jq '. + ["orders"]')
          fi
          if [ "$NOTIFICATIONS_CHANGED" == "true" ]; then
            SERVICES=$(echo "$SERVICES" | jq '. + ["notifications"]')
          fi
          
          echo "users-changed=$USERS_CHANGED" >> $GITHUB_OUTPUT
          echo "orders-changed=$ORDERS_CHANGED" >> $GITHUB_OUTPUT
          echo "notifications-changed=$NOTIFICATIONS_CHANGED" >> $GITHUB_OUTPUT
          echo "any-service-changed=$ANY_CHANGED" >> $GITHUB_OUTPUT
          echo "infra-changed=$INFRA_CHANGED" >> $GITHUB_OUTPUT
          echo "services-to-build=$SERVICES" >> $GITHUB_OUTPUT
          
          echo "Services to build: $SERVICES"

  # ============================================================
  # JOB 2: BUILD & PUSH DOCKER IMAGES (PARALLEL)
  # ============================================================
  build-and-push:
    name: Build ${{ matrix.service }}
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.any-service-changed == 'true'
    strategy:
      matrix:
        service: ${{ fromJson(needs.detect-changes.outputs.services-to-build) }}
      fail-fast: false
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_HUB_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}

      - name: Build and push ${{ matrix.service }}
        uses: docker/build-push-action@v5
        with:
          context: ./services/${{ matrix.service }}
          file: ./services/${{ matrix.service }}/Dockerfile
          push: true
          tags: |
            ${{ secrets.DOCKER_HUB_USERNAME }}/ms-${{ matrix.service }}:latest
            ${{ secrets.DOCKER_HUB_USERNAME }}/ms-${{ matrix.service }}:${{ github.sha }}
          cache-from: type=gha,scope=${{ matrix.service }}
          cache-to: type=gha,mode=max,scope=${{ matrix.service }}
          provenance: false
          sbom: false

      - name: Build summary
        run: |
          echo "âœ… ms-${{ matrix.service }} built and pushed successfully"

  # ============================================================
  # JOB 3: DEPLOY A AWS CON TERRAFORM
  # ============================================================
  deploy-to-aws:
    name: Deploy to AWS
    runs-on: ubuntu-latest
    needs: [detect-changes, build-and-push]
    if: always() && (needs.detect-changes.outputs.infra-changed == 'true' || needs.detect-changes.outputs.any-service-changed == 'true')
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
    defaults:
      run:
        shell: bash
        working-directory: ./infra
    outputs:
      users-asg: ${{ steps.get-asgs.outputs.users-asg }}
      orders-asg: ${{ steps.get-asgs.outputs.orders-asg }}
      notifications-asg: ${{ steps.get-asgs.outputs.notifications-asg }}
      infra-exists: ${{ steps.check-infra.outputs.infra-exists }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.8.5
          terraform_wrapper: false

      - name: Check if infrastructure exists
        id: check-infra
        run: |
          if [ -f "terraform.tfstate" ] && [ -s "terraform.tfstate" ]; then
            echo "âœ… Infrastructure already exists (terraform.tfstate found)"
            echo "infra-exists=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ No infrastructure found - will create from scratch"
            echo "infra-exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Initialize Terraform
        run: terraform init -migrate-state

      - name: Validate Terraform
        run: terraform validate

      - name: Format Terraform
        run: terraform fmt -recursive

      - name: Terraform Plan
        id: plan
        run: |
          terraform plan \
            -var="AWS_REGION=${{ secrets.AWS_REGION }}" \
            -var="AWS_ACCESS_KEY_ID=${{ secrets.AWS_ACCESS_KEY_ID }}" \
            -var="AWS_SECRET_ACCESS_KEY=${{ secrets.AWS_SECRET_ACCESS_KEY }}" \
            -var="AWS_SESSION_TOKEN=${{ secrets.AWS_SESSION_TOKEN }}" \
            -var="vpc_id=${{ secrets.VPC_ID }}" \
            -var="subnet1=${{ secrets.SUBNET1 }}" \
            -var="subnet2=${{ secrets.SUBNET2 }}" \
            -var="docker_hub_username=${{ secrets.DOCKER_HUB_USERNAME }}" \
            -var="image_tag=latest" \
            -var="db_username=${{ secrets.DB_USERNAME }}" \
            -var="db_password=${{ secrets.DB_PASSWORD }}" \
            -out=tfplan

      - name: Terraform Apply
        id: apply
        if: needs.detect-changes.outputs.infra-changed == 'true' || steps.check-infra.outputs.infra-exists == 'false'
        run: |
          echo "ðŸš€ Applying Terraform changes..."
          terraform apply -auto-approve tfplan

      - name: Skip Terraform Apply
        if: needs.detect-changes.outputs.infra-changed == 'false' && steps.check-infra.outputs.infra-exists == 'true'
        run: |
          echo "â­ï¸ Skipping Terraform apply - infrastructure exists and no infra changes detected"
          echo "Will only refresh instances with new Docker images"

      - name: Get Auto Scaling Group names
        id: get-asgs
        run: |
          USERS_ASG=$(terraform output -raw ms_users_asg_name 2>/dev/null || echo "ms-users-asg")
          ORDERS_ASG=$(terraform output -raw ms_orders_asg_name 2>/dev/null || echo "ms-orders-asg")
          NOTIFICATIONS_ASG=$(terraform output -raw ms_notifications_asg_name 2>/dev/null || echo "ms-notifications-asg")
          
          echo "users-asg=$USERS_ASG" >> $GITHUB_OUTPUT
          echo "orders-asg=$ORDERS_ASG" >> $GITHUB_OUTPUT
          echo "notifications-asg=$NOTIFICATIONS_ASG" >> $GITHUB_OUTPUT
          
          echo "ðŸ“‹ Auto Scaling Groups:"
          echo "  - Users: $USERS_ASG"
          echo "  - Orders: $ORDERS_ASG"
          echo "  - Notifications: $NOTIFICATIONS_ASG"

      - name: Show Terraform Outputs
        run: |
          echo "## ðŸš€ Deployment Summary"
          terraform output deployment_summary || echo "No outputs available yet"

      - name: Commit Terraform State
        run: |
          cd ..
          git config --global user.name "GitHub Actions"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Add terraform state files
          git add infra/terraform.tfstate || true
          git add infra/terraform.tfstate.backup || true
          git add infra/.terraform.lock.hcl || true
          
          # Commit if there are changes
          git diff --staged --quiet || git commit -m "Update Terraform state after deployment [skip ci]"
          
          # Push changes
          git push origin main || echo "No changes to push"

  # ============================================================
  # JOB 4: REFRESH INSTANCES (ONLY IF INFRA EXISTS & SERVICES CHANGED)
  # ============================================================
  refresh-instances:
    name: Refresh Changed Service Instances
    runs-on: ubuntu-latest
    needs: [detect-changes, build-and-push, deploy-to-aws]
    if: |
      always() && 
      needs.deploy-to-aws.outputs.infra-exists == 'true' && 
      needs.detect-changes.outputs.any-service-changed == 'true' &&
      needs.build-and-push.result == 'success'
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS CLI
        run: |
          aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws configure set aws_session_token ${{ secrets.AWS_SESSION_TOKEN }}
          aws configure set region ${{ secrets.AWS_REGION }}

      - name: Get current instances
        id: get-instances
        run: |
          echo "## ðŸ“‹ Current Instances" > instance-report.txt
          
          # Get all ASG instances
          USERS_INSTANCES=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names ${{ needs.deploy-to-aws.outputs.users-asg }} \
            --region ${{ secrets.AWS_REGION }} \
            --query "AutoScalingGroups[0].Instances[].InstanceId" \
            --output text || echo "")
          
          ORDERS_INSTANCES=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names ${{ needs.deploy-to-aws.outputs.orders-asg }} \
            --region ${{ secrets.AWS_REGION }} \
            --query "AutoScalingGroups[0].Instances[].InstanceId" \
            --output text || echo "")
          
          NOTIFICATIONS_INSTANCES=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names ${{ needs.deploy-to-aws.outputs.notifications-asg }} \
            --region ${{ secrets.AWS_REGION }} \
            --query "AutoScalingGroups[0].Instances[].InstanceId" \
            --output text || echo "")
          
          echo "ms-users: $USERS_INSTANCES" >> instance-report.txt
          echo "ms-orders: $ORDERS_INSTANCES" >> instance-report.txt
          echo "ms-notifications: $NOTIFICATIONS_INSTANCES" >> instance-report.txt
          
          cat instance-report.txt

      - name: Terminate ms-users instances (if changed)
        if: needs.detect-changes.outputs.users-changed == 'true'
        run: |
          echo "ðŸ”„ Terminating ms-users instances for refresh..."
          
          INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names ${{ needs.deploy-to-aws.outputs.users-asg }} \
            --region ${{ secrets.AWS_REGION }} \
            --query "AutoScalingGroups[0].Instances[].InstanceId" \
            --output text)
          
          for INSTANCE_ID in $INSTANCE_IDS; do
            echo "Terminating instance: $INSTANCE_ID"
            aws autoscaling terminate-instance-in-auto-scaling-group \
              --instance-id $INSTANCE_ID \
              --no-should-decrement-desired-capacity \
              --region ${{ secrets.AWS_REGION }}
            
            # Wait a bit between terminations to avoid overwhelming the ASG
            sleep 20
          done
          
          echo "âœ… ms-users instances terminated. ASG will create new instances with updated image."

      - name: Terminate ms-orders instances (if changed)
        if: needs.detect-changes.outputs.orders-changed == 'true'
        run: |
          echo "ðŸ”„ Terminating ms-orders instances for refresh..."
          
          INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names ${{ needs.deploy-to-aws.outputs.orders-asg }} \
            --region ${{ secrets.AWS_REGION }} \
            --query "AutoScalingGroups[0].Instances[].InstanceId" \
            --output text)
          
          for INSTANCE_ID in $INSTANCE_IDS; do
            echo "Terminating instance: $INSTANCE_ID"
            aws autoscaling terminate-instance-in-auto-scaling-group \
              --instance-id $INSTANCE_ID \
              --no-should-decrement-desired-capacity \
              --region ${{ secrets.AWS_REGION }}
            
            sleep 20
          done
          
          echo "âœ… ms-orders instances terminated. ASG will create new instances with updated image."

      - name: Terminate ms-notifications instances (if changed)
        if: needs.detect-changes.outputs.notifications-changed == 'true'
        run: |
          echo "ðŸ”„ Terminating ms-notifications instances for refresh..."
          
          INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names ${{ needs.deploy-to-aws.outputs.notifications-asg }} \
            --region ${{ secrets.AWS_REGION }} \
            --query "AutoScalingGroups[0].Instances[].InstanceId" \
            --output text)
          
          for INSTANCE_ID in $INSTANCE_IDS; do
            echo "Terminating instance: $INSTANCE_ID"
            aws autoscaling terminate-instance-in-auto-scaling-group \
              --instance-id $INSTANCE_ID \
              --no-should-decrement-desired-capacity \
              --region ${{ secrets.AWS_REGION }}
            
            sleep 20
          done
          
          echo "âœ… ms-notifications instances terminated. ASG will create new instances with updated image."

      - name: Wait for new instances to be healthy
        run: |
          echo "â³ Waiting for ASG to launch new instances..."
          sleep 60
          
          echo "## ðŸ†• New Instances Status"
          
          if [ "${{ needs.detect-changes.outputs.users-changed }}" == "true" ]; then
            aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names ${{ needs.deploy-to-aws.outputs.users-asg }} \
              --region ${{ secrets.AWS_REGION }} \
              --query "AutoScalingGroups[0].Instances[].[InstanceId,LifecycleState,HealthStatus]" \
              --output table
          fi
          
          if [ "${{ needs.detect-changes.outputs.orders-changed }}" == "true" ]; then
            aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names ${{ needs.deploy-to-aws.outputs.orders-asg }} \
              --region ${{ secrets.AWS_REGION }} \
              --query "AutoScalingGroups[0].Instances[].[InstanceId,LifecycleState,HealthStatus]" \
              --output table
          fi
          
          if [ "${{ needs.detect-changes.outputs.notifications-changed }}" == "true" ]; then
            aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names ${{ needs.deploy-to-aws.outputs.notifications-asg }} \
              --region ${{ secrets.AWS_REGION }} \
              --query "AutoScalingGroups[0].Instances[].[InstanceId,LifecycleState,HealthStatus]" \
              --output table
          fi

      - name: Save instance tracking file
        run: |
          # Create instances.txt with current state
          echo "# Instance Tracking - $(date)" > instances.txt
          echo "# Auto-generated by GitHub Actions" >> instances.txt
          echo "" >> instances.txt
          
          echo "[ms-users]" >> instances.txt
          aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names ${{ needs.deploy-to-aws.outputs.users-asg }} \
            --region ${{ secrets.AWS_REGION }} \
            --query "AutoScalingGroups[0].Instances[].[InstanceId,LifecycleState]" \
            --output text >> instances.txt || echo "No instances" >> instances.txt
          
          echo "" >> instances.txt
          echo "[ms-orders]" >> instances.txt
          aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names ${{ needs.deploy-to-aws.outputs.orders-asg }} \
            --region ${{ secrets.AWS_REGION }} \
            --query "AutoScalingGroups[0].Instances[].[InstanceId,LifecycleState]" \
            --output text >> instances.txt || echo "No instances" >> instances.txt
          
          echo "" >> instances.txt
          echo "[ms-notifications]" >> instances.txt
          aws autoscaling describe-auto-scaling-groups \
            --auto-scaling-group-names ${{ needs.deploy-to-aws.outputs.notifications-asg }} \
            --region ${{ secrets.AWS_REGION }} \
            --query "AutoScalingGroups[0].Instances[].[InstanceId,LifecycleState]" \
            --output text >> instances.txt || echo "No instances" >> instances.txt
          
          cat instances.txt

      - name: Commit instance tracking file
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          git add instances.txt || true
          git commit -m "Update instance tracking [skip ci]" || echo "No changes to commit"
          git push || echo "Nothing to push"

      - name: Deployment Complete
        run: |
          echo "## âœ… Deployment Completed Successfully!"
          echo "ðŸš€ Updated services:"
          echo "  - ms-users: ${{ needs.detect-changes.outputs.users-changed }}"
          echo "  - ms-orders: ${{ needs.detect-changes.outputs.orders-changed }}"
          echo "  - ms-notifications: ${{ needs.detect-changes.outputs.notifications-changed }}"
          echo ""
          echo "ðŸ“Š Check instances.txt for current instance IDs"
